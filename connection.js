// Hecho por Maycol

const {
  default: makeWASocket,
  DisconnectReason,
  useMultiFileAuthState,
  fetchLatestBaileysVersion,
  isJidBroadcast,
  isJidStatusBroadcast,
  proto,
  makeInMemoryStore,
  isJidNewsletter,
  delay,
} = require("baileys");
const moment = require("moment");
const NodeCache = require("node-cache");
const pino = require("pino");
const { BAILEYS_CREDS_DIR } = require("./config");
const { runLite } = require("./index");
const { onlyNumbers } = require("./utils/functions");
const {
  textInput,
  infoLog,
  warningLog,
  errorLog,
  successLog,
  tutorLog,
  bannerLog,
} = require("./utils/terminal");
const { welcome } = require("./welcome");

const msgRetryCounterCache = new NodeCache();
const store = makeInMemoryStore({ logger: pino().child({ level: "silent", stream: "store" }) });

bannerLog();

async function startConnection() {
  try {
    const { state, saveCreds } = await useMultiFileAuthState(BAILEYS_CREDS_DIR);
    const { version } = await fetchLatestBaileysVersion();

    const socket = makeWASocket({
      version,
      logger: pino({ level: "error" }), // solo muestra errores importantes
      store: makeInMemoryStore({ logger: pino().child({ level: "silent" }) }), // silencia el store
      printQRInTerminal: false,
      defaultQueryTimeoutMs: 60 * 1000,
      auth: state,
      shouldIgnoreJid: (jid) =>
        isJidBroadcast(jid) || isJidStatusBroadcast(jid) || isJidNewsletter(jid),
      keepAliveIntervalMs: 60 * 1000,
      markOnlineOnConnect: true,
      msgRetryCounterCache,
      shouldSyncHistoryMessage: () => false,
      getMessage: async (key) => {
        if (!store) return proto.Message.fromObject({});
        const msg = await store.loadMessage(key.remoteJid, key.id);
        return msg ? msg.message : undefined;
      },
    });

    if (!socket.authState.creds.registered) {
      warningLog("Archivos necesarios no Encontrados.");

      let enableTutor = "s";

      do {
        if (!["s", "n"].includes(enableTutor)) {
          errorLog("Opci√≥n inv√°lida");
        }
        enableTutor = await textInput("¬øDeseas un tutorial? s/n : ");
      } while (!["s", "n"].includes(enableTutor));

      const phoneNumber = await textInput("Ingrese su n√∫mero:");

      if (!phoneNumber) {
        errorLog("N√∫mero incorrecto, Ejemplo: 51921826291.");
        process.exit(1);
      }

      if (enableTutor === "s") {
        await delay(1000);
        tutorLog("Estamos generando su c√≥digo... Recuerda:\n");
        await delay(5000);
        tutorLog("‚åõ Generando c√≥digo, aguarde.. 25% completado.\n");
        await delay(10000);
        tutorLog("‚åõ Generando c√≥digo, aguarde... 50% completado.\n", "cyan");
        await delay(10000);
        tutorLog("‚åõ Generando c√≥digo, aguarde... 75% completado.\n");
        await delay(10000);
        tutorLog("‚úÖ Generaci√≥n completada! Enviando c√≥digo...\n", "green");
        await delay(5000);
      }

      const code = await socket.requestPairingCode(onlyNumbers(phoneNumber));
      infoLog(`C√≥digo: ${code}`);
    }

    socket.ev.on("connection.update", async (update) => {
      const { connection, lastDisconnect } = update;

      if (connection === "close") {
        const statusCode = lastDisconnect?.error?.output?.statusCode;

        if (statusCode === DisconnectReason.loggedOut) {
          errorLog("Borre la carpeta baileys, Bot desconectado Permanentemente");
          process.exit(1);
        } else {
          warningLog("Conexi√≥n perdida. Intentando reconectar en el menor tiempo posible...");
          setTimeout(startConnection, 300); // Espera 2 segundos antes de reconectar
        }
      } else if (connection === "open") {
        successLog("¬°El bot est√° conectado exitosamente!");

        try {
          // Cambiar la biograf√≠a del perfil del bot
          const nuevaBio = "‚òÖÂΩ°[·¥ç·¥Ä è·¥Ñ·¥è ü·¥Ä…™]ÂΩ°‚òÖ  ·¥¥·µâ·∂ú ∞·µí ·µñ·µí ≥ À¢·µí ∏·¥π·µÉ ∏·∂ú·µíÀ°";
          await socket.updateProfileStatus(nuevaBio);
          successLog("‚úÖ Biograf√≠a del bot actualizada a: " + nuevaBio);
        } catch (error) {
          errorLog("‚ùå Error al actualizar la biograf√≠a del bot.");
        }

        socket.ev.on("creds.update", saveCreds);
        socket.ev.on("messages.upsert", async ({ messages, type }) => {
          const msg = messages[0];
          if (!msg.message) return;

          const hora = moment().format("HH:mm:ss");
          const isGroup = msg.key.remoteJid.endsWith("@g.us");
          const senderID = isGroup ? msg.key.participant : msg.key.remoteJid;
          const mensajeTexto = msg.message?.conversation || msg.message?.extendedTextMessage?.text;
          const tipoMensaje = mensajeTexto ? mensajeTexto : "Contenido Multimedia o Corrupto";
          const destino = isGroup ? `Grupo: ${msg.key.remoteJid}` : `Privado: ${senderID.replace(/@s\.whatsapp\.net/, "")}`;

          console.log(`‚ú®üó®Ô∏è *Nuevo Mensaje* üí¨
- ‚è∞ | *Hora:* ${hora} | ‚è∞
- üåøüíö | *Mensaje:* ${tipoMensaje} | üíöüåø
- üë•üìû | *N√∫mero/Grupo:* ${destino} | üìûüë•
- üîÆüí´ *Hanako Kun te observa...* üîÆüí´\n`);

          runLite({ socket, data: { messages, type } });
        });
        socket.ev.on("group-participants.update", (data) => welcome({ socket, data }));

        return socket;
      }
    });

    return socket;
  } catch (error) {
    errorLog(`Error en la conexi√≥n: ${error.message}`);
    warningLog("Intentando reconectar en 1 segundo...");
    setTimeout(startConnection, 1000);
  }
}

startConnection();

// Manejo global de errores para evitar que el bot se cierre
process.on("uncaughtException", function (err) {
  if (!err.message.includes("No SenderKeyRecord found")) {
    console.error("Uncaught Exception:", err);
  }
});

process.on("unhandledRejection", function (reason) {
  if (!String(reason).includes("No SenderKeyRecord found")) {
    console.error("Unhandled Rejection:", reason);
  }
});
